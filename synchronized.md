# synchronized

## 特性

### **1.1 原子性**

**所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**

在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成**读取、计算、赋值**几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。

被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。

**注意！面试时经常会问比较synchronized和volatile，它们俩特性上最大的区别就在于原子性，volatile不具备原子性。**

### **1.2 可见性**

**可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。**

synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。

而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。

### **1.3 有序性**

**有序性值程序执行的顺序按照代码先后执行。**

synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。

### **1.4 可重入性**

## 用法

synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。

```java
public class Test {
    private int i = 0;
    private static int j = 0;
    private final Test instance = new Test();
   
    // 对成员函数加锁，必须获得该实例对象的锁才能进入同步块
    public synchronized void add1(){
        i++;
    }

    // 对静态方法加锁，必须获得类的锁才能进入同步块
    public static synchronized void add2(){
        j++;
    }

    public void method(){

        synchronized(Test.class){
            // 同步块，执行前必须先获得Test类的锁
        }

        synchronized(instance){
            // 同步块，执行前必须先获得实例对象得锁
        }
    }
}
```

首先我们知道被`static`修饰的静态方法、静态属性都是归类所有，同时该类的所有实例对象都可以访问。但是普通成员属性、成员方法是归实例化的对象所有，必须实例化之后才能访问，这也是为什么静态方法不能访问非静态属性的原因。我们明确了这些属性、方法归哪些所有之后就可以理解上面几个synchronized的锁到底是加给谁的了。

首先看第一个`synchronized`所加的方法是`add1()`，该方法没有被`static`修饰，也就是说该方法是归实例化的对象所有，那么这个锁就是加给`Test1`类所实例化的对象。

然后是`add2()`方法，该方法是静态方法，归`Test1`类所有，所以这个锁是加给`Test1`类的。

最后是`method()`方法中两个同步代码块，第一个代码块所锁定的是`Test1.class`，通过字面意思便知道该锁是加给`Test1`类的，而下面那个锁定的是`instance`，这个`instance`是`Test1`类的一个实例化对象，自然它所上的锁是给`instance`实例化对象的。

分析如下代码：

![image-20211210102220089](https://ryze-halo-blog.oss-cn-beijing.aliyuncs.com/halo-blog/image-20211210102220089.png)

上面的简单意思就是用两个线程分别对i加100万次，理论结果应该是200万，而且我还加了synchronized锁住了add方法，保证了其线程安全性。可是！！！我无论运行多少次都是小于200万的，为什么呢？

我开始也想不通，emmm多思考一下好像又明白了：`synchronized`是加在对象方法上的，由于两个线程中的对象并不相同，所以它们执行add方法的时候并不会去争夺某个资源；就比如一开始都是0的时候，它们都加了1，写回主存，这样加了两次但结果确是1。

### 疑惑

> 疑惑：但上面不是说`synchronized`是可见的吗？难道是因为加锁加的是add()方法，而不是`i`吗？我感觉可以通过给`i`加锁，或者把`add()`方法申明为静态的来解决这个问题。

## **synchronized锁的实现**

这个在[这篇文章](https://what-yes.top/archives/%E9%94%81%E6%9C%BA%E5%88%B6#toc-head-7)有过介绍（跳过去就直接到对应标题了），就懒得写了。

> 转自： [深入理解synchronized底层原理，一篇文章就够了！ - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1465413)

