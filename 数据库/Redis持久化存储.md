# Redis持久化存储

## RDB

在指定的时间间隔内将内存中的数据集快照写入磁盘。

### 备份如何执行的？

Redlis.,会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何Io操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。**RDB的缺点是最后一次持久化后的数据可能丢失。**

#### 为什么会挂掉？

比如save 20 5，但在16s的时候只有3个发生改变，而且服务器此时宕机了，这部分数据就不会持久化。

![image-20211206100552561](https://ryze-halo-blog.oss-cn-beijing.aliyuncs.com/halo-blog/image-20211206100552561.png)

### 配置文件

`save a b`  在a秒中有b个key发生改变，那么就进行持久化操作。

`rdbchecksum` 校验和， 10%性能损失

### 命令 save 和 bgsave

`save` : save时只管保存，其它不管，全部阻塞。手动保存。不建议。

`bgsave` :Redis.会在后台异步进行快照操作，快照同时还可以响应客户端请求。

### 优势

1. 适合大规模的数据恢复
2. 对数据完整性和一致性要求不高更适合使用节省磁盘空间
3. 恢复速度快

### 劣势

1. Fork的时候，内存中的数据被克隆了一份，大致2T倍的膨胀性需要考虑虽然 Redis.
2. 在 fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。
3. 在备份周期在一定间隔时间做一次备份，所以如果Redis.,意外 down掉的话，就会丢失最后一次快照后的所有修改。

## AOF Append Only File

以日志的形式来记录每个写操作(增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)，**只许追加文件但不可以改写文件**，**redis启动之初会读取该文件重新构建数据**，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

AOF默认不开启

RDB和AOF同时开启，系统默认取AOF的数据。

![image-20211206103733421](https://ryze-halo-blog.oss-cn-beijing.aliyuncs.com/halo-blog/image-20211206103733421.png)

### AOF同步频率

- appendfsync always
  始终同步，每次 Redis的写入都会立刻记入日志;性能较差但数据完整性比较好,
- appendfsync everysec
  每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。
- appendfsync no
  redis不主动进行同步，把同步时机交给操作系统

### 重写压缩

比如 `set a1 b1` `set a2 b2` 会被压缩为  `set a1 b1 a2 b2`

重写操作触发时机：

Redis 会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次 rewrite后大小的一倍且文件大于64M 时触发。

### AOF持久化流程：

1. 客户端的请求写命令会被append追加到AOF缓冲区内;
2. AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中;
3. AOF文件大小超过重写策略或手动重写时，会对 AOF文件rewrite重写，压缩AOF文件容量;
4. Redis 服务重启时，会重新load加载 AOF 文件中的写操作达到数据恢复的目的;

#### 优点：

1. 备份机制更稳健，丢失数据概率更低。
   可读的日志文本，通过操作AOF稳健，可以处理误操作。

#### 缺点：

1. 比起RDB占用更多的磁盘空间。
2. 恢复备份速度要慢。
3. 每次读写都同步的话，有一定的性能压力。
4. 存在个别 Bug，造成恢复不能。·